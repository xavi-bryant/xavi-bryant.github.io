{"pages":[{"title":"photos","text":"未实现。。。","link":"/photos/index.html"},{"title":"关于我","text":"谢谢你来看看我！！！","link":"/about/index.html"}],"posts":[{"title":"call、apply、bind区别","text":"介绍这两个方法都是函数对象的方法，需要通过函数对象来调用。 当函数调用call()和apply()时，函数都会立即执行。 都可以用来改变函数的this对象的指向。 第一个参数都是this要指向的对象（函数执行时，this将指向这个对象），后续参数用来传实参。 显式绑定thisJS提供的绝大多数函数以及我们自己创建的所有函数，都可以使用call 和apply方法。 它们的第一个参数是一个对象。因为你可以直接指定 this 绑定的对象，因此我们称之为显式绑定。 例1： 12345678910function foo() { console.log(this.a);}var obj = { a: 2};// 将 this 指向 objfoo.apply(obj); //打印结果：2 第一个参数的传递1、thisObj不传或者为null、undefined时，函数中的this会指向window对象（非严格模式）。 2、传递一个别的函数名时，函数中的this将指向这个函数的引用。 3、传递的值为数字、布尔值、字符串时，this会指向这些基本类型的包装对象Number、Boolean、String。 4、传递一个对象时，函数中的this则指向传递的这个对象。 call()和apply()的区别call()和apply()方法都可以将实参在对象之后依次传递，但是apply()方法需要将实参封装到一个数组中统一传递（即使只有实参只有一个，也要放到数组中）。 比如针对下面这样的代码： 12345678910111213var persion1 = { name: \"小王\", gender: \"男\", age: 24, say: function (school, grade) { alert(this.name + \" , \" + this.gender + \" ,今年\" + this.age + \" ,在\" + school + \"上\" + grade); }}var person2 = { name: \"小红\", gender: \"女\", age: 18} 如果是通过call的参数进行传参，是这样的： 1persion1.say.call(persion2, \"实验小学\", \"六年级\"); 如果是通过apply的参数进行传参，是这样的： 1persion1.say.apply(persion2, [\"实验小学\", \"六年级\"]); 看到区别了吗，call后面的实参与say方法中是一一对应的，而apply传实参时，要封装成一个数组，数组中的元素是和say方法中一一对应的，这就是两者最大的区别。 call()和apply()的作用 改变this的指向 实现继承。Father.call(this) bind() 都能改变this的指向 call()/apply()是立即调用函数 bind()是将函数返回，因此后面还需要加()才能调用。 bind()传参的方式与call()相同。 参考链接： https://www.jianshu.com/p/56a9c2d11adc https://github.com/lin-xin/blog/issues/7 https://segmentfault.com/a/1190000007402815 JS中改变this指向的方法","link":"/2019/06/20/call、apply、bind的区别/"},{"title":"递归","text":"执行栈 尾递归 函数直接或者间接调用自身 避免无限递归 ，无限递归会导致执行栈溢出 对比死循环 死循环不会报错，也不会导致栈溢出 无限递归会导致栈溢出 不刺激你学的明白？ 执行栈无论任何代码的执行都必须有一个执行环境，执行环境为代码提供支持 执行环境是放到执行栈中的。 每个函数调用，都需要创建一个函数的执行环境，函数调用结束执行环境销毁。 执行栈有相对固定的，如果执行环境太多，执行无法容纳，会报错。 尾递归如果一个函数的最后一条语句是调用函数，并且调用函数不是表达式的一部分，则该函数称之为尾递归。","link":"/2019/04/20/digui/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy","link":"/2018/08/20/hello-world/"},{"title":"git基础入门","text":"Git是一款免费、开源的分布式 版本控制系统 ，用于敏捷高效地处理任何或小或大的项目。 git的历史 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 git的安装下载地址 注意： 不要安装在中文目录 不要使用桌面管理软件 安装很简单，一直下一步即可。在任意的目录下右键，能看到菜单, 就表示安装成功了。 git三个区要对某个项目使用git进行管理，需要使用git init命令初始化git仓库git init会在当前目录生成一个隐藏文件夹 .git 不要去修改这个文件夹下的任意东西。 git仓库会分成三个区 工作区：我们书写代码的地方，工作的目录就叫工作区。 暂存区：暂时存储的区域，在git中，代码无法直接从工作区提交到仓库区，而是需要先从工作区添加到暂存区，然后才能从暂存区提交到仓库区。暂存区的目的是避免误操作。 本地仓库区：将保存在暂存区域的内容永久转储到 Git 仓库中，生成版本号。生成版本号之后，就可以任何的回退到某一个具体的版本。 git基本命令git init 作用：初始化git仓库，想要使用git对某个项目进行管理，需要git init进行初始化 12# 初始化仓库， 在当前目录下生成一个隐藏文件夹.gitgit init git add 作用：将文件由 工作区 添加到 暂存区，在git中，文件无法直接从工作区直接添加到仓库区，必须先从工作区添加到暂存区，再从暂存区添加到仓库区。 命令：git add 文件名/目录名 12345678910111213# 将index.html添加到暂存区git add index.html# 将css目录下所有的文件添加到暂存区git add css# 将当前目录下所有的js文件添加到暂存区git add *.js# 添加当前目录下所有的文件git add .git add -Agit add --all git commit作用：将文件由 暂存区 添加到 仓库区，生成版本号 1234567891011# 将文件从暂存区提交到仓库git commit -m \"提交说明\"# 如果不写提交说明，会进入vi编辑器，没有写提交说明，是提交不成功的。git commit # 需要使用vi输入内容# 如果是一个已经暂存过的文件，可以快速提交，如果是未追踪的文件，那么命令将不生效。git commit -a -m '提交说明'# 修改最近的一次提交说明， 如果提交说明不小心输错了，可以使用这个命令git commit --amend -m \"提交说明\" git config配置如果是第一次提交，需要配置提交者信息，推荐和github的账号邮箱一致 12345678910111213# git config user.name 你的目标用户名# git config user.email 你的目标邮箱名# 使用--global参数，配置全局的用户名和邮箱，只需要配置一次即可。推荐配置github的用户名和密码git config --global user.name jepsongit config --global user.email jepsonpp@qq.com# 查看配置信息git config --list# 取消配置git config --unset --global user.namegit config --unset --global user.email git status 作用：查看文件的状态 命令：git status 红色表示工作区中的文件需要提交 绿色表示暂存区中的文件需要提交 命令：git stauts -s 简化日志输出格式 git log 作用：查看提交日志 git log 查看提交的日志 git log --oneline 简洁的日志信息 git重置git reset 作用：版本回退，将代码恢复到已经提交的某一个版本中。 git reset --hard 版本号 将代码回退到某个指定的版本(版本号只要有前几位即可) git reset --hard head~1将版本回退到上一次提交 ~1:上一次提交 ~2:上上次提交 ~0:当前提交 当使用了git reset命令后，版本会回退，使用git log只能看到当前版本之前的信息。使用git reflog可以查看所有的版本信息 git忽视文件 在仓库中，有些文件是不想被git管理的，比如数据的配置密码、写代码的一些思路，node_modules等。git可以通过配置从而达到忽视掉一些文件，这样这些文件就可以不用提交了。 在仓库的根目录创建一个.gitignore的文件，文件名是固定的。 将不需要被git管理的文件路径添加到.gitignore中 1234567891011# 忽视idea.txt文件idea.txt# 忽视css下的index.js文件css/index.js# 忽视css下的所有的js文件css/*.js# 忽视css文件夹css git分支操作分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。 如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！ 为什么要有分支？ 如果你要开发一个新的功能，需要2周时间，第一周你只能写50%代码，如果此时立即提交，代码没写完，不完整的代码会影响到别人无法工作。如果等代码写完再提交，代码很容易丢失，风险很大。 有了分支，你就可以创建一个属于自己的分支，别人看不到，也不影响别人，你在自己的分支上工作，提交到自己的分支上，等到功能开发完毕，一次性的合并到原来的分支。这样既安全，又不影响他人工作。 git分支命令 在git中，分支实质上仅仅是一个指针，每次代码提交后，这个分支指针就会向后移动，保证一直指向最后一次提交的的版本。git中使用HEAD指向当前分支 创建分支 git branch 分支名称创建分支，分支中的代码，在创建时与当前分支的内容完全相同。 git在第一次提交时，就有了一个叫master的主分支。 git branch dev，创建了一个叫做dev的分支 查看分支 git branch可以查看所有的分支， 在当前分支的前面会有一个* 在git中，有一个特殊指针HEAD,永远会指向当前分支 切换分支 git checkout 分支名称切换分支 HEAD指针指向了另一个分支 在当前分支的任何操作，都不会影响到其他的分支，除非进行了分支合并。 提交代码时，会生产版本号，当前分支会指向最新的版本号。 创建并切换分支 git checkout -b 分支名称 创建并切换分支 切换分支会做两件事情 创建一个新分支 把head指针指向当前的分支 删除分支 git branch -d 分支名称 可以删除分支 注意：不能在当前分支删除当前分支，需要切换到其他分支才能删除。 注意：master分支是可以删除的，但是不推荐那么做。 合并分支 git merge 分支名称 将其他分支的内容合并到当前分支。 在master分支中执行git merge dev 将dev分支中的代码合并到master分支 分支合并 git合并冲突 对于同一个文件，如果有多个分支需要合并时，容易出现冲突。 合并分支时，如果出现冲突，只能手动处理，再次提交，一般的作法，把自己的代码放到冲突代码的后面即可。 git远程仓库github与gitgit与github没有直接的关系。 git是一个版本控制工具。 github是一个代码托管平台，开源社区，是git的一个远程代码仓库。 123//1. gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。//2. github免费，代码所有人都能看到，但是只有你自己能修改。付费的可以隐藏。//3. 创建git项目时，不能有中文。 github官网 开源中国-git git clone 作用：克隆远程仓库的代码到本地 git clone [远程仓库地址] git clone git://github.com/jepson/test.git会在本地新建一个test文件夹，在test中包含了一个.git目录，用于保存所有的版本记录，同时test文件中还有最新的代码，你可以直接进行后续的开发和使用。 git克隆默认会使用远程仓库的项目名字，也可以自己指定。需要是使用以下命令：git clone [远程仓库地址] [本地项目名] git push 作用：将本地仓库中代码提交到远程仓库 git push 仓库地址 master 在代码提交到远程仓库，注意master分支必须写，不能省略 例子：git push git@github.com:jepson/test.git master 如果第一次使用，需要填写github的用户名和密码 git pull 作用：将远程的代码下载到本地 通常在push前，需要先pull一次。 12# 获取远程仓库的更新，并且与本地的分支进行合并git pull git remote每次push操作都需要带上远程仓库的地址，非常的麻烦，我们可以给仓库地址设置一个别名 12345678# 给远程仓库设置一个别名git remote add 仓库别名 仓库地址git remote add jepson git@github.com:jepson/test.git# 删除jepson这个别名git remote remove jepson# git clone的仓库默认有一个origin的别名 SSH免密码登陆git支持多种数据传输协议： https协议：https://github.com/jepson/test.git 需要输入用户名和密码 ssh协议：git@github.com:jepson/test.git 可以配置免密码登录 每次push或者pull代码，如果使用https协议，那么都需要输入用户名和密码进行身份的确认，非常麻烦。 github为了账户的安全，需要对每一次push请求都要验证用户的身份，只有合法的用户才可以push 使用ssh协议，配置ssh免密码，可以做到免密码往github推送代码 SSH免密码登录配置注意：这些命令需要在bash中敲 1 创建SSH Key：ssh-keygen -t rsa 2 在文件路径 C:\\用户\\当前用户名\\ 找到 .ssh 文件夹 3 文件夹中有两个文件： 私钥：id_rsa 公钥：id_rsa.pub 4 在 github -&gt; settings -&gt; SSH and GPG keys页面中，新创建SSH key 5 粘贴 公钥 id_rsa.pub 内容到对应文本框中 5 在github中新建仓库或者使用现在仓库，拿到git@github.com:用户名/仓库名.git 6 此后，再次SSH方式与github“通信”，不用输入密码确认身份了","link":"/2018/12/20/git/"}],"tags":[{"name":"javacript","slug":"javacript","link":"/tags/javacript/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"git","slug":"git","link":"/tags/git/"}],"categories":[{"name":"js基础","slug":"js基础","link":"/categories/js基础/"},{"name":"数据算法","slug":"数据算法","link":"/categories/数据算法/"},{"name":"HTML和CSS基础","slug":"HTML和CSS基础","link":"/categories/HTML和CSS基础/"},{"name":"git","slug":"git","link":"/categories/git/"}]}